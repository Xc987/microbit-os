{".vscode/extensions.json":"{\n    \"recommendations\": [\"ms-edu.pxt-vscode-web\"]\n}",".vscode/settings.json":"{\n    \"editor.formatOnType\": true,\n    \"files.autoSave\": \"afterDelay\",\n    \"files.watcherExclude\": {\n        \"**/.git/objects/**\": true,\n        \"**/built/**\": true,\n        \"**/node_modules/**\": true,\n        \"**/yotta_modules/**\": true,\n        \"**/yotta_targets\": true,\n        \"**/pxt_modules/**\": true,\n        \"**/.pxt/**\": true\n    },\n    \"files.associations\": {\n        \"*.blocks\": \"html\",\n        \"*.jres\": \"json\"\n    },\n    \"search.exclude\": {\n        \"**/built\": true,\n        \"**/node_modules\": true,\n        \"**/yotta_modules\": true,\n        \"**/yotta_targets\": true,\n        \"**/pxt_modules\": true,\n        \"**/.pxt\": true\n    },\n    \"files.exclude\": {\n        \"**/pxt_modules\": true,\n        \"**/.pxt\": true\n    }\n}","README.md":"```package\nmeter=github:grandpabond/pxt-meter\n```\n# meter --- Adding values to your project!\n\nMany microbit projects are about taking measurements. The datalogger extension lets you make a historical \nrecord of your measurements, but your project can often be brought to life by adding a real-time visual \nindicator. The  ``||meter:meter||`` extension provides various ways to let you monitor a changing value.\n\nThe default meter shows a direct 2-digit readout of a value, which should lie in the range [0...99].\nFor many purposes 2 digits provide enough accuracy, especially when showing readings as percentages.\n\n### ~reminder\nNOTE:  Since each digit uses only 10 pixels, they are inevitably somewhat stylized. So it takes a \nbit of practice to read the digital meter accurately  --especially the digits \"0\" and \"8\"\n### ~\n\n## Displaying a value #meter-show\n\n```sig\nmeter.show(value,  ms)\n```\nThis block adjusts the meter to show a new reading.\n\n> ``||meter:value||`` - is the new value to be shown.\n\nIf you click on the \"+\", you can set an optional parameter:\n\n> ``||meter:ms||`` - is used to control the settling time of an animated adjustment to the new value. \nThe meter will display in-between values, arriving at the new ``||meter:value||`` after ms millisecs.  \n\n### ~reminder\nNOTE: If you try to show a value that is too big or too small, your meter will stop at the \nnearest end, but will then flash to indicate the \"out-of-range\" error.\n### ~\n\n## Choosing an indicator meter #meter-use\n\n```sig\nmeter.use(style, start, limit)\n```\nOften the exact numeric value is less important than providing a rapid visual indication of a measurement.\nThe ``||meter:meter.use()||`` block lets you select one of a number of possible visual indicators, with \nvarying resolutions.\n\n> ``||meter:style||`` - chooses one of the indicator Styles (see below)\n\n> ``||meter:start||`` - is the value that maps to the bottom reading\n\n> ``||meter:limit||`` - is the value that maps to the top reading\n\n### ~reminder\nThe range for indicator displays is completely flexible: when ``||meter:start||`` is bigger \nthan ``||meter:limit||``, higher values will just show lower readings. Either end can be a negative value, and they \nneed not even be whole numbers: fractional values are quite OK.\n### ~\n\n### Indicator Styles:\n\n> ``||meter:Styles.Bar||``This meter style (similar to the built-in ``||led:led.plotBarGraph||`` block) fills up \neach row in turn from the bottom, with 1, 3, or 5 centred pixels, giving a total of 15 distinct displays.\n\n> ``||meter:Styles.Dial||``\nThis meter style shows a short 3-pixel pointer rotating from the 12 o'clock position through 24 different angles.\n  \n> ``||meter:Styles.Needle||``\nThis meter style show a needle pivoting on the top left corner. It swings clockwise from horizontal to vertical in 17 steps.\n\n> ``||meter:Styles.Tidal||``\nThis meter style fills the display progressively from the bottom left to the top right in 25 steps.\n\n> ``||meter:Styles.Blob||``\nThis meter style is a simple centred disc that grows from a single pixel to fill the screen in 7 steps. \n\n> ``||meter:Styles.Spiral||``\nThis meter style is similar to the Blob, but winds round clockwise in a spiral to fill the screen in 25 steps.\n\n## Showing numbers with the digital meter #meter-digital\n\n```sig\nmeter.digital()\n```\nUse this block to switch back to showing numerical measurements. The range will always be from \"00\" to \"99\". \n(Any other values will flash the out-of-range error.)\n\n\n## Stopping display animation #meter-hide\n\n```sig\nmeter.freeze()\n```\nUse this block to stop background changes to the meter, interrupting any animated \nadjustment or (more usefully) turning off out-of-range error flashing.\n\n## Hiding the meter #meter-hide\n\n```sig\nmeter.hide()\n```\nWhen you no longer want to display a meter, this block clears the display.\n\n# Examples\n\nHere are some ideas for using ``||meter:meter||`` blocks to monitor various microbit readings...\n\n## Thermometer\nThis code uses the default digital meter to show the current microbit temperature (constrained \nto the range 0 degrees to 99 degrees):\n\n```blocks\nbasic.forever(function () {\n    meter.show(input.temperature());\n    basic.pause(5000);\n});\n```\n\n## Clicker\nA simple use of the default digital meter lets you count things up (with Button B) and down \n(with Button A). Possibly useful for counting people at an event; or cars in a carpark; \nor even sheep in a pen, though the limit is 99!\n\n```blocks\nlet count = 0;\n\ninput.onButtonPressed(Button.B, function () {\n    count += 1;\n    if (count > 100) {\n        count = 100;\n    }\n    meter.show(count);\n});\n\ninput.onButtonPressed(Button.A, function () {\n    count += -1;\n    if (count < -1) {\n        count = -1;\n    }\n    meter.show(count);\n});\n```\n\n## Breath Trainer\nA tiny example to guide your breathing, using your chosen visual indicator. (Try them all out in turn!)\n\n```blocks\nmeter.use(meter.Styles.Bar, -1, 1);\nlet y = 0;\nbasic.forever(function () {\n    y = Math.sin(input.runningTime() / 1500);\n    meter.show(y);\n})\n```\n\n## Bangometer\nThis example monitors jolts and knocks using the ``||meter:Styles.Blob||`` indicator. The size \nof the displayed \"blob\" roughly shows a rolling average of the strength of each bang \n(up to a maximun of 1000 milli-gravities). \nThe indicator then dies away over a time of 1.5 seconds. \n\n```blocks\nmeter.use(meter.Styles.Blob, 50, 1000);\nlet gravityWas = 1000;\n\nbasic.forever(function () {\n    basic.pause(20);\n    gravity = input.acceleration(Dimension.Strength);\n    bang = Math.abs(gravity - gravityWas);\n\tif (bang > 50) { \n\t\tmeter.show(bang);\n\t\tbasic.pause(50);\n\t\tmeter.show(50, 1500);\n\t}\n    gravityWas = gravity;\n});\n```          \n\t \n## Compass\nThe following code uses the rotary ``||meter:Styles.Dial||`` style to show a compass needle that (should) \nalways point North. Note that the dial uses a reversed scale counting from 360 degrees down to zero. \n(You will first have to tilt the screen as instructed to calibrate the magnetometer to its surroundings)\n\n```blocks\ninput.calibrateCompass();\nbasic.pause(2000);\nmeter.use(meter.Styles.Dial, 359, 0);\n\nbasic.forever(function () { \n    // to centralise pointer, offset readings anti-clockwise\n    let pointer= (input.compassHeading() + 352.5) % 360\n    meter.show(pointer);\n    basic.pause(500);\n});\n```\n\n## Noise Meter\nThe following code uses the ``||meter:Styles.Spiral||`` style to show peak noise levels, sampled four times a \nsecond. The animated spiral uses a rolling average, so grows gradually and then slowly unwinds over time. \nIf it's too loud the indicator will flash to show a range error.\n\n```blocks\nmeter.use(meter.Styles.Spiral, 40, 80);\nlet value = 60;\n\nbasic.forever(function () {\n    value = (value + input.soundLevel()) / 2;\n    meter.show(value,800);\n    basic.pause(250);\n})\n```\n\n## Water Spill\nThis example uses the ``||meter:Styles.Tidal||`` indicator to simulate spilling water from the bottom left \nto the top right as you tilt the microbit. \nA rolling average and a half-second animation delay makes the movement smoother and adds some viscosity.\n\n```blocks\nmeter.use(meter.Styles.Tidal, -30, 20);\nlet value = 60;\n\nbasic.forever(function () {\n    value = (value + input.rotation(Rotation.Roll) - input.rotation(Rotation.Pitch))/2\n\tmeter.show(value, 500);\n    basic.pause(1000);\n});\n```\n\n## Plumb-line\nFor this use of the accelerometer we'll need a function to compute the Yaw rotation. This is then continuously \nmapped (displaced by a right-angle, plus a bit extra) onto the ``||meter:Styles.Dial||`` indicator, so that the needle always hangs downwards.\n\n```blocks\nmeter.use(meter.Styles.Dial, 0, 360);\n\nfunction rotationYaw():number {\n\tlet ax = input.acceleration(Dimension.X);\n\tlet ay = input.acceleration(Dimension.Y);\n\treturn (Math.atan2(ay, ax) * 180 / Math.PI);\n}\n\nbasic.forever(function () {\n// to centralise pointer, offset yaw clockwise\n\tmeter.show(((rotationYaw() + 457.5) % 360)) \n    basic.pause(1000);\n});\n```\n\n# Lie-detector\nThis final example uses the ``||meter:Styles.Needle||`` indicator to monitor the capacitive input on Pin2 of the microbit \n(which may or may not reflect the truthfulness of the person touching it!).\n\nThe value is a rolling average, and despite possible inputs ranging from [0 .. 1023], the sensitivity \nhas been experimentally focused onto a smaller working range of [600 .. 900].\n\n```blocks\nmeter.use(meter.Styles.Needle, 600, 900);\npins.touchSetMode(TouchTarget.P2, TouchTargetMode.Capacitive);\nlet value = 700;\n\nbasic.forever(function () {\n    value = (value + pins.analogReadPin(AnalogPin.P2)) / 2;\n    meter.show(value);\n    basic.pause(500);\n});\n```\n\n\n\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n> Open this page at [https://grandpabond.github.io/pxt-meter/](https://grandpabond.github.io/pxt-meter/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/grandpabond/pxt-meter** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/grandpabond/pxt-meter** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","pxt-meter.ts":"/**\n * an extension for displaying a reading,\n * digitally or with a scaled analogue indicator.\n */\n\n//% color=#6070c0 weight=40 icon=\"\\uf163\" block=\"Meter\" \nnamespace meter {\n\n    /* Default style is DIGITAL: a 2-digit readout from 0 to 99\n        Each digit uses a 10-bit bitmap (0...1023) encoding pixels vertically\n        from 2 adjacent display columns, either {0,1} or {3,4}:\n            2^0=1   2^5=32\n            2^1=2   2^6=64\n            2^2=4   2^7=128\n            2^4=8   2^8=256\n            2^5=16  2^9=512\n        combined as ((tensMap << 15) + unitsMap) to give a full bitmap \n    */\n    const digitMaps = [\n        0x1CE,  // 462,  //\"0\" \n        0x3E0,  // 992,  //\"1\" \n        0x2FD,  // 765,  //\"2\" \n        0x3F5,  // 1013, //\"3\" \n        0x38F,  // 911,  //\"4\" \n        0x3B7,  // 951,  //\"5\" \n        0x39F,  // 927,  //\"6\" \n        0x3E1,  // 993,  //\"7\" \n        0x37B,  // 891,  //\"8\" \n        0x3E7]; // 999   //\"9\" \n    const digitBound = 99;\n    const digitStyle = -1;\n\n    /* displayed frames are coded column-wise from top-left as 25-bit bit-maps:\n    */\n    // DIAL: 24 frames rotate 3-pixel pointer about middle\n    const dialMaps = [\n        0x0001C00, 0x0009800, 0x0019000, 0x0111000, 0x0211000, 0x0221000,\n        0x0421000, 0x0821000, 0x0841000, 0x1041000, 0x00C1000, 0x0083000,\n        0x0007000, 0x0003200, 0x0001300, 0x0001110, 0x0001108, 0x0001088,\n        0x0001084, 0x0001082, 0x0001042, 0x0001041, 0x0001060, 0x0001820];\n    const dialBound = 23;\n\n    // BLOB: 7 frames growing outwards from middle\n    const blobMaps = [\n        0x0001000, 0x0023880, 0x00739C0, 0x0477DC4,\n        0x06F7DEC, 0x0EFFFEE, 0x1FFFFFF];\n    const blobBound = 6;\n\n    // BAR: 15 frames of vertical bar-graph  \n    const barMaps = [\n        0x0004000, 0x0084200, 0x1084210, 0x1086210, 0x10C6310, 0x18C6318,\n        0x18C7318, 0x18E7398, 0x1CE739C, 0x1CE7B9C, 0x1CF7BDC, 0x1EF7BDE,\n        0x1EF7FDE, 0x1EFFFFE, 0x1FFFFFF];\n    const barBound = 14;\n\n    // SPIRAL: 25 frames winding outwards from middle\n    const spiralMaps = [\n        0x0001000, 0x0021000, 0x0061000, 0x0063000, 0x0063100, 0x0063180,\n        0x00631C0, 0x00639C0, 0x00739C0, 0x02739C0, 0x06739C0, 0x0E739C0,\n        0x1E739C0, 0x1EF39C0, 0x1EF79C0, 0x1EF7BC0, 0x1EF7BD0, 0x1EF7BD8,\n        0x1EF7BDC, 0x1EF7BDE, 0x1EF7BDF, 0x1EF7BFF, 0x1EF7FFF, 0x1EFFFFF, 0x1FFFFFF];\n    const spiralBound = 24;\n\n    // TIDAL: 25 frames washing diagonally up from bottom-left corner\n    const tidalMaps = [\n        0x0000010, 0x0000210, 0x0000218, 0x000021C, 0x000031C, 0x000431C,\n        0x008431C, 0x008631C, 0x008639C, 0x008639E, 0x008639F, 0x00863DF,\n        0x00873DF, 0x00C73DF, 0x10C73DF, 0x18C73DF, 0x18E73DF, 0x18E7BDF,\n        0x18E7BFF, 0x18E7FFF, 0x18F7FFF, 0x1CF7FFF, 0x1EF7FFF, 0x1EFFFFF,\n        0x1FFFFFF];\n    const tidalBound = 24;\n\n    // SPEEDOMETER: 13 frames rotate 3-pixel needle from left side\n    const speedometerMaps = [\n        0x0001110, 0x0001108, 0x0001084, 0x0001042, 0x0001041, 0x0001060,\n        0x0001C00, 0x0019000, 0x0111000, 0x0211000, 0x0421000, 0x0841000,\n        0x1041000];\n    const speedometerBound = 12;\n\n    // SIGNAL: 15 frames growing in signal form\n    const signalMaps = [\n        0x0000010, 0x0000210, 0x0000310, 0x0004310, 0x0006310, 0x0007310,\n        0x0087310, 0x00C7310, 0x00E7310, 0x00F7310, 0x10F7310, 0x18F7310,\n        0x1CF7310, 0x1EF7310, 0x1FF7310];\n    const signalBound = 14;\n\n    // NEEDLE: 17 frames swinging clockwise around top-left corner\n    const needleMaps = [\n        0x0108421, 0x0208421, 0x0210421, 0x0210841, 0x0410841, 0x0420841,\n        0x0820841, 0x0821041, 0x0041041, 0x0083041, 0x00820C1, 0x00060C1,\n        0x00041C1, 0x0000383, 0x0000307, 0x000020F, 0x000001F];\n    const needleBound = 16;\n\n    // NEEDLE: 15 frames swinging clockwise around top-left corner // Im not sure where are the 2 missing frames.\n    const needlerevMaps = [\n        0x1084210, 0x0884210, 0x0844210, 0x0842110, 0x0442110, 0x0422110,\n        0x0221110, 0x0111110, 0x0009910, 0x0008990, 0x00005D0, 0x00000F8,\n        0x000007C, 0x000003E, 0x000001F];\n    const needlerevBound = 14;\n\n    // WATER: 25 frames filling up the screen from the bottom\n    const waterMaps = [\n        0x1000000, 0x1080000, 0x1084000, 0x1084200, 0x1084210, 0x1084218,\n        0x1084318, 0x1086318, 0x10C6318, 0x18C6318, 0x1CC6318, 0x1CE6318,\n        0x1CE7318, 0x1CE7398, 0x1CE739C, 0x1CE739E, 0x1CE73DE, 0x1CE7BDE,\n        0x1CF7BDE, 0x1EF7BDE, 0x1FF7BDE, 0x1FFFBDE, 0x1FFFFDE, 0x1FFFFFE,\n        0x1FFFFFF];\n    const waterBound = 24;\n\n    export enum Styles {\n        //%block=\"blob\"\n        Blob,\n        //%block=\"spiral\"\n        Spiral,\n        //%block=\"bar\"\n        Bar,\n        //%block=\"dial\"\n        Dial,\n        //%block=\"needle\"\n        Needle,\n        //%block=\"tidal\"\n        Tidal\n    }\n    export enum Styles2 {\n        //%block=\"needle\"\n        Needlerev,\n        //%block=\"speedometer\"\n        Speedometer,\n        //%block=\"signal\"\n        Signal,\n        //%block=\"water\"\n        Water\n    }\n    const AnimateID = 9020; // event source ID\n    const FinishedEvent = 1;\n\n    let styleIs: number = digitStyle;\n    let mapSet: number[] = digitMaps; // array of frame bit-maps\n    let bound: number = digitBound;   // highest frame-index\n    let fromValue: number = 0;     // the user's start value\n    let uptoValue: number = 99;    // the user's end value\n    let valueNow: number = 0;      // the user's latest value\n\n    /* We save the bit-maps of the pixels currently lit, and needing to be lit:\n      Computing (litMap XOR newMap) then shows which pixels will need to be toggled.\n      Bits are allocated column-wise top-to-bottom and left-to-right,\n      so pixel[x,y] contributes 2**(x*5 + y) to the 25-bit map.\n      (This matches the 2-column encoding used for each digit in digitStyle)\n    */\n    let litMap: number = 0;\n    let newMap: number = 0;\n    let litFrame: number = -1; // currently displayed frame (-1 says none)\n    let rangeFixed = false;    // notify overflow/underflow\n    let flashError = false;    // finalFrame was out of range before correction\n    let canShow = false;   // true while animate() fiber allowed to run in inBackground\n    let isShowing = false; // true while animate() fiber is actively showing/flashing frames\n    let firstFrame = 0;    // animation start-value\n    let finalFrame = 0;    // animation end-value\n    let when = 0;          // animation starting time\n    let then = 0;          // animation target end time\n    let tick = 0;          // animation adjusting interval\n    let flashGap = 166;    // flashing around 3 times/sec\n\n    let max = 100\n    let speed = 50\n    let proc = 0 //test\n    let stage = 0 //test\n    let startpos = 0 //test\n    let poslist = [4, 4, 4, 4, 4] //test\n\n    function mapToFrame(value: number, start: number, end: number,\n        startFrame: number, endFrame: number): number {\n        let result = endFrame;\n        let span = end - start; // (can be negative)\t\n        let frames = endFrame - startFrame; // (can go backwards)\t\n        if (startFrame > endFrame) { // count the end frame too\n            frames--;\n        } else {\n            frames++;\n        }\n        if (span != 0) {\n            let frac = (value - start) / span;\n            result = Math.floor(startFrame + (frac * frames));\n        }\n        return result;\n    }\n\n    function fixRange(value: number, oneEnd: number, otherEnd: number): number {\n        // NOTE side effect: sets rangeFixed true if out-of-range, else clears it\n        let bottom = Math.min(oneEnd, otherEnd);\n        let top = Math.max(oneEnd, otherEnd);\n        let result2 = value;\n        rangeFixed = false;\n        if (value < bottom) {\n            rangeFixed = true;\n            result2 = bottom;\n        }\n        if (value > top) {\n            rangeFixed = true;\n            result2 = top;\n        }\n        return Math.round(result2)\n    }\n\n    // modify display to show new frame\n    // which will always lie within the range [0..bound]\n    // except for digitStyle, when it will be within [0..99]\n    function showFrame(frame: number) {\n        if (styleIs == digitStyle) {\n            let tens = ~~(frame / 10); // ~~ enforces integer result\n            let units = frame % 10;\n            // left-shift \"units\" map by 3 columns over to right side (=15 bits)\n            // then OR-in \"tens\" map to occupy left 2 columns\n            newMap = (mapSet[units] << 15) | mapSet[tens];\n        } else {\n            newMap = mapSet[frame];\n        }\n        // see which pixels differ\n        let toToggle = newMap ^ litMap;\n        toggleColumnMap(toToggle);\n        litMap = newMap;\n        litFrame = frame;\n    }\n\n    // toggle the state of all pixels indicated in the 25-bit column-map: toToggle\n    function toggleColumnMap(toToggle: number) {\n        let bitmap = toToggle;\n        for (let x = 0; x < 5; x++) { // column-wise from top-left\n            for (let y = 0; y < 5; y++) {\n                if (bitmap & 1) {\n                    led.toggle(x, y);\n                }\n                bitmap >>= 1;\n            }\n        }\n    }\n\n    // Perform background tasks: adjust the meter (maybe stepwise)\n    // and when finalFrame reached, flash if range-error signalled\n    // (Sleeps between interations, but must be prepared to terminate prematurely)\n    function animate(): void {\n        isShowing = true;\n        while (canShow) {\n            if (litFrame == -1) { // (NOTE: on first use litFrame will be -1)\n                showFrame(finalFrame);\n                litFrame = finalFrame;\n            }\n            if (litFrame != finalFrame) {\n                // NOTE: \"then\" was the target finish time for adjustment. \n                // That time may already have passed if this fiber got delayed by other \n                // unpredictable scheduled work, so code our progress defensively...\n                let now = Math.min(input.runningTime(), then);\n                //  work out frame we should have got to by \"now\", possibly skipping some\n                let nextFrame = mapToFrame(now, when, then, firstFrame, finalFrame);\n                nextFrame = fixRange(nextFrame, 0, bound); // may have overshot\n                showFrame(nextFrame);\n                if (nextFrame == finalFrame) {\n                    tick = 10; // we've now arrived, so minimise final pause below\n                }\n            } else {  //... we've arrived, so do we need to flash or just exit?\n                if (flashError) {\n                    pause(flashGap);  // (cedes control to scheduler for quite a while)\n                    if (litMap != 0) {\n                        basic.clearScreen();\n                        litMap = 0;\n                    } else {\n                        showFrame(litFrame);\n                    }\n                } else {\n                    canShow = false; // all done, so self-terminate next time round!\n                }\n            }\n            pause(tick); // (always cede control to scheduler to allow other work)\n        }\n        // while loop has terminated, so signal our completion, then exit\n        control.raiseEvent(AnimateID, FinishedEvent);\n        isShowing = false;\n    }\n\n    // EXPORTED USER INTERFACES  \n\n    /** \n     * Show a new value for meter (immediately, or adjusting gradually over time)\n     * @param value new value to be shown, eg: 66\n     * @param ms (optional) settling time in millisecs for the new value, eg: 250\n     */\n    //% block=\"show meter value= $value || , taking $ms ms\" \n    //% inlineInputMode=inline\n    //% expandableArgumentMode=\"enabled\"\n    //% weight=100\n    export function show(value: number, ms = 0) {\n        // cease any ongoing animation (leaves any current litFrame lit)\n        if (isShowing) { freeze() }\n        finalFrame = mapToFrame(value, fromValue, uptoValue, 0, bound);\n        finalFrame = fixRange(finalFrame, 0, bound); // NOTE: may set rangeFixed!\n        flashError = rangeFixed; // if so, remember the fact\n        firstFrame = litFrame; // the inherited start-frame (may be -1 if none)\n        when = input.runningTime();\n        then = when + ms;\n        if ((finalFrame == firstFrame) || (ms == 0)) {\n            tick = 10; // (minimal, just to allow for interruption)\n        } else {\n            tick = Math.round(ms / Math.abs(finalFrame - firstFrame));\n        }\n        // allow background task to adjust display, flashing final frame if needed \n        canShow = true;\n        if (!isShowing) {\n            control.inBackground(function () { animate() });\n        }\n\n    }\n\n    /**\n     * Choose a non-numeric visual indicator for showing future values\n     * together with the range of values it will indicate\n     * @param style your choice of indicator style eg: meter.Style.Bar\n     * @param start the value that maps to the bottom reading eg: 32\n     * @param limit the value that maps to the top reading eg: 212\n     */\n    //% block=\"use $style meter to show values from $start to $limit\" \n    //% style.defl=meter.Styles.Bar\n    //% start.defl=0\n    //% limit.defl=20\n    //% weight=90\n    export function use(style: Styles, start: number, limit: number) {\n        styleIs = style;\n        fromValue = start;\n        uptoValue = limit;\n        hide();\n        switch (style) {\n            case Styles.Dial:\n                mapSet = dialMaps;\n                bound = dialBound;\n                break;\n            case Styles.Needle:\n                mapSet = needleMaps;\n                bound = needleBound;\n                break;\n            case Styles.Bar:\n                mapSet = barMaps;\n                bound = barBound;\n                break;\n            case Styles.Blob:\n                mapSet = blobMaps;\n                bound = blobBound;\n                break;\n            case Styles.Spiral:\n                mapSet = spiralMaps;\n                bound = spiralBound;\n                break;\n            case Styles.Tidal:\n                mapSet = tidalMaps;\n                bound = tidalBound;\n                break;\n        }\n    }\n\n    /**\n     * Use the digital counter for showing future values\n     */\n    //% block=\"use digital meter to indicate values from 0 to 99\"\n    //% weight=80 \n    export function digital() {\n        hide();\n        styleIs = digitStyle;\n        fromValue = 0;\n        uptoValue = 99;\n        mapSet = digitMaps; // NOTE: the 10 numeric frames...\n        bound = digitBound; // ...combine to allow 100 values\n    }\n\n    /**\n     * Stop the meter, interrupting any animation or flashing\n     */\n    //% block=\"freeze meter\"\n    //% weight=40 \n    export function freeze() {\n        if (isShowing) {\n            // terminate any background activity (adjusting or flashing) and await event\n            // saying that the animate() fiber has wakened; noticed; and finished off\n            canShow = false;\n            control.waitForEvent(AnimateID, FinishedEvent);\n            if (litMap == 0) { // ensure litFrame was left visible after possible flashing\n                showFrame(litFrame);\n            }\n        }\n    }\n\n    /**\n     * Hide the meter, stopping any animation or flashing\n     */\n    //% block=\"hide meter\"\n    //% weight=30 \n    export function hide() {\n        freeze(); // interrupt any animation\n        basic.clearScreen();\n        litMap = 0;\n        litFrame = -1;\n    }\n    //% block=\"use $style meter to show values from $start to $limit\" \n    //% style.defl=meter.Styles2.Speedometer\n    //% start.defl=0\n    //% limit.defl=20\n    //% weight=20\n    //% group=\"Extended\"\n    export function use2(style: Styles2, start: number, limit: number) {\n        styleIs = style;\n        fromValue = start;\n        uptoValue = limit;\n        hide();\n        switch (style) {\n            case Styles2.Needlerev:\n                mapSet = needlerevMaps;\n                bound = needlerevBound;\n                break;\n            case Styles2.Speedometer:\n                mapSet = speedometerMaps;\n                bound = speedometerBound;\n                break;\n            case Styles2.Signal:\n                mapSet = signalMaps;\n                bound = signalBound;\n                break;\n            case Styles2.Water:\n                mapSet = waterMaps;\n                bound = waterBound;\n                break;\n        }\n    }\n    //% block=\"use moving meter to show $variable , maximum value $max with speed $speed\"\n    //% variable.defl=66\n    //% max.defl=100\n    //% speed.defl=50\n    //% speed.shadow=\"timePicker\"\n    //% weight=20\n    //% group=\"Extended\"\n    export function animateduse (variable: number, max: number, speed: number) {\n        \n            proc = variable / max\n            proc = proc * 100\n            proc = Math.trunc(proc)\n            if (proc <= 20 && proc < 21) {\n                startpos = 4\n                led.plot(4, 4)\n            } else if (proc <= 40 && proc < 41) {\n                startpos = 3\n                led.plot(4, 3)\n            } else if (proc <= 60 && proc < 61) {\n                startpos = 2\n                led.plot(4, 2)\n            } else if (proc <= 80 && proc < 81) {\n                startpos = 1\n                led.plot(4, 1)\n            } else if (proc <= 90 || proc >= 90) {\n                startpos = 0\n                led.plot(4, 0)\n            }\n            poslist[stage] = startpos\n            stage += 1\n            if (stage == 5) {\n                stage = 0\n            }\n            if (stage == 0) {\n                led.plot(3, poslist[3])\n                led.plot(2, poslist[2])\n                led.plot(1, poslist[1])\n                led.plot(0, poslist[0])\n            }\n            if (stage == 1) {\n                led.plot(3, poslist[4])\n                led.plot(2, poslist[3])\n                led.plot(1, poslist[2])\n                led.plot(0, poslist[1])\n            }\n            if (stage == 2) {\n                led.plot(3, poslist[0])\n                led.plot(2, poslist[4])\n                led.plot(1, poslist[3])\n                led.plot(0, poslist[2])\n            }\n            if (stage == 3) {\n                led.plot(3, poslist[1])\n                led.plot(2, poslist[0])\n                led.plot(1, poslist[4])\n                led.plot(0, poslist[3])\n            }\n            if (stage == 4) {\n                led.plot(3, poslist[2])\n                led.plot(2, poslist[1])\n                led.plot(1, poslist[0])\n                led.plot(0, poslist[4])\n            }\n            basic.pause(speed)\n            basic.clearScreen()\n    }\n}\n","pxt.json":"{\n    \"name\": \"meter-extended\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \".vscode/extensions.json\",\n        \".vscode/settings.json\",\n        \"README.md\",\n        \"pxt-meter.ts\",\n        \"test.ts\",\n        \"testFiles/test.ts\",\n        \"tsconfig.json\",\n        \"tutorial-info-cache.json\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v7.0.51\",\n        \"tag\": \"v7.0.51\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/c3819f016bd720d0eb86efea9a84dcd4fc7b2e1f\",\n        \"target\": \"7.0.51\",\n        \"pxt\": \"11.1.5\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"","testFiles/test.ts":"","tsconfig.json":"{\n    \"compilerOptions\": {\n        \"target\": \"ES5\",\n        \"noImplicitAny\": true,\n        \"outDir\": \"built\",\n        \"rootDir\": \".\"\n    },\n    \"exclude\": [\"pxt_modules/**/*test.ts\"]\n}\n","tutorial-info-cache.json":"{\"https://github.com/grandpabond/pxt-meter\":{\"snippetBlocks\":{\"36e9a3765dcf2d21674fef882497f6d74ce1e9555bda462f2d96144f1e648fb6\":{\"device_forever\":1,\"meter_show\":1,\"device_temperature\":1,\"device_pause\":1},\"ae4d2223a69d7d657c7d046fc92e1cba34760f64dea5b7857a0315e58eb5a573\":{\"device_button_event\":2,\"variables_change\":2,\"controls_if\":2,\"logic_compare\":2,\"variables_set\":2,\"meter_show\":2,\"variables_get\":4},\"bcda53988d477918a473b6aec5bc711f62906342c19a7c7700ec3c481e092e93\":{\"device_forever\":1,\"pxt-on-start\":1,\"variables_set\":1,\"meter_use\":1,\"math_js_op\":1,\"meter_show\":1,\"math_arithmetic\":1,\"variables_get\":1,\"device_get_running_time\":1},\"a93d0d00e13122a49b1aa100d117ff36abc7f862652f0012176175309e0c1ac7\":{\"device_forever\":1,\"pxt-on-start\":1,\"device_pause\":2,\"meter_use\":1,\"variables_set\":4,\"device_acceleration\":1,\"math_op3\":1,\"controls_if\":1,\"math_arithmetic\":1,\"logic_compare\":1,\"meter_show\":2,\"variables_get\":5},\"afc76a8748cd02fe67a6a53b6ebf87fe0509a92b8df9692635c8f42935f8cf90\":{\"device_forever\":1,\"pxt-on-start\":1,\"meter_show\":1,\"input_compass_calibrate\":1,\"device_heading\":1,\"device_pause\":2,\"meter_use\":1},\"fe1d0fc50a4afdd2b154a199d5a446a41b628d0df346fa89a24a6d9ffd6b3b3b\":{\"device_forever\":1,\"pxt-on-start\":1,\"variables_set\":2,\"meter_use\":1,\"math_arithmetic\":2,\"meter_show\":1,\"variables_get\":2,\"device_pause\":1,\"device_get_sound_level\":1},\"2080ea1c4e2e152c30fd8c66366ecbd1bfa2988fd09c4f1fdd395974d2a83fcc\":{\"device_forever\":1,\"pxt-on-start\":1,\"variables_set\":2,\"meter_use\":1,\"math_arithmetic\":3,\"meter_show\":1,\"variables_get\":2,\"device_pause\":1,\"device_get_rotation\":2},\"60eab8db1dfe6eeecd50aaa882a4733188703b383102febfcfa09e61fd12fac5\":{\"function_definition\":1,\"device_forever\":1,\"pxt-on-start\":1,\"variables_set\":2,\"meter_show\":1,\"meter_use\":1,\"device_acceleration\":2,\"math_modulo\":1,\"device_pause\":1,\"math_arithmetic\":1,\"function_call_output\":1},\"f617e6f8d4492f9c147fe7a5ee757d33a2c73e878d386b50ac82e6123d04f551\":{\"device_forever\":1,\"pxt-on-start\":1,\"variables_set\":2,\"meter_use\":1,\"math_arithmetic\":2,\"meter_show\":1,\"device_touch_set_type\":1,\"variables_get\":2,\"device_pause\":1,\"device_get_analog_pin\":1}},\"usedBlocks\":{\"device_forever\":1,\"meter_show\":1,\"device_temperature\":1,\"device_pause\":1,\"device_button_event\":1,\"variables_change\":1,\"controls_if\":1,\"logic_compare\":1,\"variables_set\":1,\"variables_get\":1,\"pxt-on-start\":1,\"meter_use\":1,\"math_js_op\":1,\"math_arithmetic\":1,\"device_get_running_time\":1,\"device_acceleration\":1,\"math_op3\":1,\"input_compass_calibrate\":1,\"device_heading\":1,\"device_get_sound_level\":1,\"device_get_rotation\":1,\"function_definition\":1,\"math_modulo\":1,\"function_call_output\":1,\"device_touch_set_type\":1,\"device_get_analog_pin\":1},\"highlightBlocks\":{\"36e9a3765dcf2d21674fef882497f6d74ce1e9555bda462f2d96144f1e648fb6\":{},\"ae4d2223a69d7d657c7d046fc92e1cba34760f64dea5b7857a0315e58eb5a573\":{},\"bcda53988d477918a473b6aec5bc711f62906342c19a7c7700ec3c481e092e93\":{},\"a93d0d00e13122a49b1aa100d117ff36abc7f862652f0012176175309e0c1ac7\":{},\"afc76a8748cd02fe67a6a53b6ebf87fe0509a92b8df9692635c8f42935f8cf90\":{},\"fe1d0fc50a4afdd2b154a199d5a446a41b628d0df346fa89a24a6d9ffd6b3b3b\":{},\"2080ea1c4e2e152c30fd8c66366ecbd1bfa2988fd09c4f1fdd395974d2a83fcc\":{},\"60eab8db1dfe6eeecd50aaa882a4733188703b383102febfcfa09e61fd12fac5\":{},\"f617e6f8d4492f9c147fe7a5ee757d33a2c73e878d386b50ac82e6123d04f551\":{}},\"hash\":\"e7889b0233d1187afae98687dafaa5c5b532320c5062a4c2ff3e5080fb695d8a\"}}"}